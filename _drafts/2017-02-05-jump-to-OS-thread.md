---
layout: post
title: "Jump To OS : Thread"
date: "2017-02-12"
---

OS 2탄이 돌아왔습니다! 하하.. 하나의 포스트로 정리하려고 했는데 역시나 OS는 넓고 어렵습니다 ㅠㅠ 이번에는 Thread입니다.

스레드는 CPU 사용의 기본 단위다. 스레드 ID, 프로그램 카운터, 레지스터 세트 및 스택을 포함한다.

![thread](/images/2017-02-05-jump-to-OS/thread.PNG)

## Motivation

단일 응용 프로그램이 여러 가지 유사한 task를 수행해야 할 수도 있다. 예를 들어, 웹 서버는 웹 페이지, 이미지, 사운드 등에 대한 클라이언트 요청을 받아들인다. 사용량이 많은 웹 서버에는 여러 클라이언트가 동시에 액세스 할 수 있다. 웹 서버가 기존의 single thread process로 실행되면 한 번에 하나의 클라이언트만 서비스 할 수 있으며 클라이언트는 요청을 처리하는 데 오랜 시간을 기다려야 할 수 있다.
한 가지 해결책은 서버가 요청을 각각의 single process로 실행되도록하는 것이다. 서버가 요청을 수신하면 서버는 해당 요청을 처리 할 별도의 process를 쓴다. 그러나 process 생성은 많은 시간과 자원을 필요로 한다.

## Benefits

1. Responsiveness. 쌍방향 응용 프로그램의 다중 스레드는 프로그램은 작업의 일부가 차단되거나 긴 작업을 수행하는 경우에도 프로그램이 계속 실행되도록하여 사용자의 입력에 대한 응답 속도를 높인다. 특히 사용자 인터페이스 설계에 유용하다. 예를 들어 사용자가 시간이 많이 걸리는 작업을 수행하는 버튼을 클릭하면 단일 스레드 응용 프로그램은 작업이 완료 될 때까지 사용자에게 응답하지 않는다. 반대로 시간이 많이 걸리는 작업이 별도의 스레드에서 수행되는 경우 응용 프로그램은 사용자에게 응답한다.
2. Resource sharing. 프로세스는 Shared Memory 및 Message passing과 같은 기술을 통해서만 리소스를 공유 할 수 있다. 이러한 기술은 프로그래머가 명시적으로 구성(하드코딩)해야한다. 그러나 스레드는 메모리와 기본적으로 속한 프로세스의 리소스를 공유한다. 
3. Economy. 프로세스 생성을 위해 메모리와 리소스를 할당하는 것은 많은 비용이 든다. 스레드는 스레드가 속한 프로세스의 리소스를 공유하기 때문에 스레드를 만들고 context-switch 하는 것이 더 경제적이다. 오버 헤드의 차이를 경험적으로 측정하는 것은 어려울 수 있지만 일반적으로 스레드보다 프로세스를 만들고 관리하는 데 훨씬 많은 시간이 소요된다. 예를 들어 솔라리스에서 프로세스 생성은 스레드를 만드는 것보다 약 30 배 느리고 context-switch은 약 5 배 느리다.
4. Scalability. 스레드가 다른 프로세싱 코어에서 병렬로 실행될 수 있는 멀티 프로세서 아키텍처에서는 멀티 스레딩의 이점을 훨씬 크게 누릴 수 있습니다. 단일 스레드 프로세스는 사용 가능한 프로세서 수에 관계없이 하나의 프로세서에서만 실행될 수 있습니다.

# Multicore Programming

코어들(2개이상)이 CPU 칩 전체 또는 CPU 칩 안에서 존재하면 멀티 코어 또는 멀티 프로세서 시스템이라고 한다.

![singlecore](/images/2017-02-05-jump-to-OS/singlecore.PNG)
![multicore](/images/2017-02-05-jump-to-OS/multicore.PNG)


동시성은 싱글 코어에서 멀티 스레드를 동작시키기 위한 방식으로 멀티 태스킹을 위해 여러 개의 스레드가 번갈아가면서 실행되는 성질을 말한다. 동시성을 이용한 싱글 코어의 멀티 태스킹은 각 스레드들이 병렬적으로 실행되는 것처럼 보이지만 사실은 번갈아가면서 조금씩 실행되고 있는 것이다. 병렬성은 멀티 코어에서 멀티 스레드를 동작시키는 방식으로, 한 개 이상의 스레드를 포함하는 각 코어들이 동시에 실행되는 성질을 말한다. 따라서 병렬 처리없이 동시성을 가질 수 있다.

## Type of Parallelism

일반적으로 병렬 처리에는 데이터 병렬 처리와 작업 병렬 처리의 두 가지 유형이 있다. 
데이터 병렬 처리는 전체 데이터를 쪼개 서브 데이터들로 만든 뒤, 서브 데이터들을 병렬 처리하여 작업을 빠르게 수행하는 것을 말한다. 자바 8에서 지원하는 병렬 스트림이 데이터 병렬성을 구현한 것이다. 서브 데이터는 멀티 코어의 수만큼 쪼개어 각각의 데이터들을 분리된 스레드에서 병렬 처리한다. 작업 병렬 처리는 서로 다른 작업을 병렬 처리하는 것을 말한다. 대표적인 예는 웹 서버로, 각각의 브라우저에서 요청한 내용을 개별 스레드에서 병렬로 처리한다.
기본적으로 데이터 병렬 처리는 여러 코어에서의 데이터 배포와 여러 코어에서의 작업 분산에 대한 작업 병렬 처리를 포함한다. 대부분의 경우 응용 프로그램은 이 두 가지 전략을 섞어서 사용한다.

# Multithreading Models

스레드에 대한 지원은 사용자 수준에서의 user thread 또는 커널에 의해 제공되는 kernel thread을 제공받을 수 있다. 사용자 스레드는 커널 위에서 작동하고 커널 지원없이 관리되며 커널 스레드는 운영 체제에서 직접 지원 및 관리된다.

## Many-to-One Model

다대일 모델은 여러개의 user thread를 하나의 kernel thread로 관리하는 모델이다. thread library를 사용해서 관리하며 효율적인 방법이다. 그러나 하나의 thread가 block을 호출하면 나머지 thread도 block당하며 하나의 kernel thread를 사용하기 때문에 다중 코어 시스템에서의 병렬처리가 불가능하다.

![many-to-one-model](/images/2017-02-05-jump-to-OS/many-to-one-model.PNG)

## One-to-One Model

일대일 모델은 하나의 user thread를 하나의 kernel thread로 관리하는 모델이다. 이 모델은 동시성도 우수하고 다중 코어 시스템에서의 병렬처리도 가능하고 block에 독립적이기 때문에 빠르다. 다만 단점은 User thread가 많아짐으로서 kernel thread도 같이 많아지기 과부하가 걸리게 된다.

![one-to-one-model](/images/2017-02-05-jump-to-OS/one-to-one-model.PNG)

## Many-to-Many Model

다대다 모델은 여러개의 user thread를 user thread의 수보가 적게 kernel thread로 관리하는 모델이다. 개발자는 필요한만큼의 사용자 스레드를 만들 수 있으며 해당 커널 스레드는 다중 프로세서에서 병렬로 실행할 수 있다. 또한 스레드가 블로킹 system call을 수행 할 때 커널은 다른 스레드의 실행을 예약 할 수 있다. 위의 모델들의 장단점이 분명하기 때문에 이 두가지 모델의 장점을 섞어서 만들어진 것이 two-level model이다.

![many-to-many-model](/images/2017-02-05-jump-to-OS/many-to-many-model.PNG)
![two-level-model](/images/2017-02-05-jump-to-OS/two-level-model.PNG)


---------

대략적인 내용 정리 

* Boot loader 작동 프로세스 정리
* kernel - shell
* API in OS
* Job & task
  * Job = 사용자가 컴퓨터에게 일을 시키는 단위 = program group
  * Job Step = Job을 작게 나눈 단위 ==> 순차적으로 실행됨
  * Task = OS입장에서의 최소 단위 ==> Job Step을 나누어서 처리하기 위함.
  * Task를 보통 Process 혹은 Task라고 합니다.
* Interrupt
  * 실행 중인 프로그램을 중단하고 우선순위가 높은 다른 프로그램에게 CPU를 할당하여 실행하는 것.
  * 내부 인터럽트(소프트웨어 인터럽트), 외부 인터럽트(하드웨어 인터럽트)
    * 내부 인터럽트
      * 오버플로우 : 허가받은 영역이상의 메모리를 사용할 경우
      * 페이지 폴트 : 허가받지 않은 영역의 메모리를 참조하는 경우
      * 트레이스 : 디버그를 위해 프로그램을 한 명령씩 실행 하는 경우
      * 슈퍼파이져 콜 : 시스템 콜을 사용 한 경우
      * 명령 코드 이상 : 무효한 명령을 실행하는 경우
    * 외부 인터럽트
      * 기계 체크 인터럽트 : 하드웨어가 이상이 있을 경우
      * 타이머 인터럽트 : 일정시간 마다(주기적으로) 인터럽트를 강제로 발생시기는 경우
      * 입출력 인터럽트 : 입출력기기의 상태 변환시 발생
      * 콘솔 인터럽트 : 입출력기기의 조작시 발생
* Process
  * 사용자가 프로그램을 실행하면 OS는 그 내용을 메모리상으로 읽어드린다(로드). 로드된 프로그램을 프로세스라고 하며 하나의 프로그램은 한 개 이상의 프로세스를 만든다.
  * 멀티태스킹 : 여러 개의 task가 병행하여 작동하는 것.
  * TSS(Time Sharing System) : 여러 사용자에게 CPU 권한을 단시간동안 할당하는 시스템
  * Process Status
    * 대기 상태 : 입출력 동작을 기다리고 있는 상태
    * 실행 가능 상태 : CPU의 사용 권한 할당을 기다리고 있는 상태
    * 실행 상태 : 프로세스에 CPU의 사용 권한이 할당되어 실행되고 있는 상태
    * 대기 ==> 실행 가능 : 입출력 인터럽트
    * 실행 가능 ==> 실행 : 디스패치
    * 실행 ==> 실행 가능 : 프리엠션
    * ![asd](https://image.slidesharecdn.com/intermediateos-120421041906-phpapp01/95/intermediate-operating-systems-36-728.jpg?cb=1334982260)
  * 멀티태스킹 종류
    * 프리엠티브 : OS가 Task의 CPU의 사용권을 할당하고 강제적으로 태스크를 전환하는 방식.
    * 논프리엠티브 : Task가 CPU의 사용권을 정하고 할당 해제를 하는 방식
  * 프로세스 제어
    * PSW(Program Status Word) : 인터럽트로 인핸 중단된 프로그램의 상태나 연산의 종료 상태를 저장해 두는 레지스터
    * PCB(Process Control Block) : 각 프로세스의 CPU 상태(context)나 프로세스의 상태를 저장해두는 메모리 영역
    * 컨텍스트 스위치 : 인터럽트로 인한 Process 전환시 OS가 PCB를 저장하고 복원하는 것.
  * Scheduling(스케줄링)
    * OS가 여러 개의 프로세스를 처리할 떄 CPU를 할당할 순서를 정하는 것.
      * 스케줄러 방식
        * Round Robin : 프로세스가 기다리고 있는 순서대로 일정시간 처리 후 맨 뒤로 돌림.
        * 우선순위 방식 : 프로세스의 우선순위를 정해서 처리하는 방식
  * 프로세스 분기
    * fork()
      * 시스탬 콜을 이용하여 프로세스를 복사함.
      * 복사의 모체를 부모 프로세스, 복사 당한 객체를 자식 프로세스라 함.
      * 서로 다른 PCB를 사용하며 복사 당시 차이점은 자식 프로세스의 리턴 값(PID)는 0이다.
    * exec()
      * 복사된 자식 프로세스를 다른 프로그램에서 실행 하도록 지시하는 것.
    * wait()
      * 자식 프로세스를 종료시키는 시스탬 콜
      * 자식 프로세스가 끝나면 부모 프로세스가 진행됨.
  * 프로세스 동기(sync)
    * 배타 제어
      * 프로세스의 처리가 끝날 때까지 하나의 프로세스에게 자원을 독점시키는 것.
      * 여러 개의 프로세스가 파일이나 데이터베이스에 동시에 엑세스하면 데이터의 무결성(완벽하게 정확하다, 에러가 없다)이 손상 될 수 있다.
    * 세마포어 ([자료1](http://wonjayk.tistory.com/250), [자료2](https://webcache.googleusercontent.com/search?q=cache:HaPnCiqIUnQJ:https://www.joinc.co.kr/w/Site/system_programing/IPC/semaphores+&cd=7&hl=ko&ct=clnk&gl=kr), [자료3](http://croute.me/3))
      * 정해진 수 이상의 프로세스가 공유 자원에 동시에 엑세스 하지 않도록 카운터를 사용하여 제어하는 장치
      * 세마포어 작동 순서
        1. 세마포어는 운영체계 또는 커널의 한 지정된 저장장치 내 값이다.
        2. 값의 변경은 P와 V라는 명령에 의해서 이루어진다.
        3. 프로세스가 Critical section에 들어가면 P는 세마포의 값을 감소시킨다.
        4. 프로세스가 작업수행 후 Critical section에서 나오면 V가 세마포 값을 증가시킨다.
        5. 프로세스는 확인되는 값에 따라 자원을 활용, 또는 일정시간을 대기한다.
  * 데드락 (Deadlock)
    * 2개의 프로세스가 각자 사용하는 공유 자원을 잠근 체 서로의 공유 자원을 액세스 하려고 대기하는 상태. 
    * 이 경우 서로 무한하게 대기하게 된다.
    * 뮤텍스 : 카운터 값이 1인 세마포어와 같다.
  * 프로세스 간 통신
    * 프로세스는 각각의 독립된 메모리를 사용한다. 그래서 서로간의 데이터를 교환하지 못한다.
    * 프로세스끼리 통신을 할 떄는 OS를 거처서 통신한다.
    * 통신 종류
      * 메시지 큐 : OS의 메시지 큐를 사용하여 통신(1:1)
      * 파이프 : 여러 개의 프로세스 입출력을 연결하는 장치. 부모 자식 프로세스 간의 통신에 사용됨
      * 이름 붙은 파이프 : 위의 파이프와 같지만 부모 자식 프로세스 간 이외에도 사용이 가능하다.
  * 공유 메모리 : 여러 개의 프로세스에서 공통으로 사용할 수 있는 메모리 영역. 시스탬 콜을 사용하며 접속(attach), 연결해제(detach)를 이용한다.
  * 스레드
    * 프로세스 안에 프로그램 실행의 흐름
    * 분기가 가능해 여러 개의 스레드를 동시에 실행한다.( = 멀티스레드)
    * 멀티 프로세스와 멀티 스레드의 차이점은 멀티 프로세스는 각각의 독립된 메모리 공간을 사용하지만 멀티 스레드는 하나의 프로세스안에서 돌기 때문에 하나의 메모리를 사용한다.
