---
layout: post
title: "Jump To OS?"
date: "2017-02-05"
---

# Intro

OS는 중요하고 프로그래머라면 누구든지 알고 있어야 하는 것이다. 라는 말을 프로그래밍하시는 분들이나 전산과 계열에서 대학을 졸업하신 분들이라면 한번쯤은 들어보셨겠죠? 그래서 저도 막상 대학에선 잘 이해 하지 못했던 운영체제에 대한 공부를 결심한 한지 약 2년째 되어가는 차에.. 회사 공부 발표를 운영체제로 정해버렸습니다.. ㅠㅠ 이걸 2주만에 공부할 수 있었던건 정말로 신입적응기간이기 때문인것 같은데... 이번에 정리를 잘 해놔서 가치 있는 글을 남겨보려 합니다.(뭐 또 끝내놓으면 사라질 글일 느낌이 없진 않습니다..)




# Process Concept

프로세스는 단순히 실행되고 있는 코드를 뜻하는 것이 아니다. 프로세스는 많은 것을 가지고 있는데 아래에 나열해본다.

![process-in-memory](/images/2017-02-05-jump-to-OS/process-in-memory.PNG)

* Program Counter : 명령어 주소 레지스터라고 불리우며 다음 번에 실행될 명령어의 주소를 가지고 있는 저장소.
* Stack : 임시적인 데이터(function parameters, return addresses, local variables)를 가지는 저장소이며 메모리 끝부터 0번지 방향으로 자료가 쌓인다.
* data section : global variables 저장소.
* heap : process가 실행되는 시간에 동적으로 할당되는 메모리 공간.

Program은 Process가 아니다. Program은 디스크에 저장된 실행코드의 리스트(실행파일)들 같은 **passive entity**이다. 반면 Process는 다음실행해야할 실행코드와 그 실행코드가 엮인 리소스와 같은 **active entity**이다. Program이 process가 되기 위해선 실행파일이 메모리로 불러와져야 한다. 같은 프로그램을 여러 사용자가 동시에 사용하거나 한 사용자가 같은 프로그램을 여러개 실행하여 사용하여도 동일한 process를 사용하는 것이 아닌 각각의 실행된 프로그램의 process를 사용하게 되는 것이다. process는 자신이 아닌 다른 process를 실행할 수 있다.

## Process State

[참고가 된 자료](http://operatingsystems.tistory.com/entry/OS-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%ACProcess-Management)

![process-in-memory](/images/2017-02-05-jump-to-OS/diagram-of-process-state.PNG)

* New : Process가 만들어 진다.
* Running : 명령어가 실행되어지고 있다.
* Waiting : 어떠한 이벤트(I/O interrupt 등)로 인해서 기다리게 됨.
* Ready : 프로세서에 할당되길 기다린다.
* Terminated : 프로세스가 종료 되었다.


## PCB (Process Control Block)

OS안에서 각각의 process는 Process Contral Block(PCB)로 표현된다.

![PCB](/images/2017-02-05-jump-to-OS/PCB.PNG)

* Process state : 현재 프로세스의 상태이다( ready, waiting, running 등등)
* Program counter : 이 프로세스가 다음에 실행시켜야 할 명령어의 주소값.
* CPU registers : 프로세스의 다양한 상태값(stack pointer, condition code, index register)이나 interrupt로 인한 waiting 상황 발생시 process의 모든 값을 저장하는 장소.

![CPU-switch](/images/2017-02-05-jump-to-OS/CPU-switch.PNG)

* CPU-Scheduling infomation : cpu가 처리하는 스케쥴링 큐의 포인터나 스케쥴링의 기준이 되는 값을 저장.
* Memory-management information : OS가 관리하는 Memory ststem의 page table이나 segment table, base register, limit register 값이 들어있다.

![base-limit-register](/images/2017-02-05-jump-to-OS/base-limit-register.PNG)

* Accounting infomation : (process가) 사용중인 CPU, 실 사용시간, time limits, account numbers, job or process numbers 등의 정보가 들어있다.
* I/O status infomation : process에 할당된 I/O devices 리스트, 열고 있는 files 등의 정보가 들어있다.

# Process Scheduling

멀티프로그래밍의 목적 중 하나는 CPU가 노는 시간을 줄이는 것이다. 시분할의 목적은 process를 cpu에 자주 할당시켜 각각의 프로그램이 도는동안 상호 호환시키기 위해서다. 이 목적들을 위해 **process Scheduler**는 사용가능한 process를 선택하여 CPU에 실행시킨다.

## Scheduling Queues

process가 시스탬에 속하면 process는 **Job Queue**에 올라간다. process가 memory에 로딩이 되는 순간부터 ready나 Waiting상태일 경우 **Ready Queue**에 올라간다. **Ready Queue**는 보통 linked list로 저장이 되며 첫부분과 끝부분의 포인터를 가지는 구조이고, 각각의 PCB블럭은 각자 자신의 다음 실행해야할 PCB를 가리킨다.

**Job Queue**에는 다른 queue들이 존재한다. process가 CPU에 할당이 될 떄, process가 실행 중 갑작스럽게 종료 되거나, interrupt 당하거나, I/O Event를 기다리기 되기도 한다.

![Job-Queue](/images/2017-02-05-jump-to-OS/Job-Queue.PNG)

새로운 process는 ready queue에 들어간다. 그러고 실행될 때(dispatched) 까지 기다린다. process가 CPU에 처리되는 동안 몇가지 이밴트가 발생할 수 있다.

* I/O Queue에 있던 I/O request가 발생한다.
* 새로운 자식 process가 발생하고 자식 process가 끝나기를 기다려야한다.
* process는 interrupt로 인해 강제적으로 CPU에서 제거 될 수 있다.
* 모든 이벤트가 발생하면 CPU에 있던 process는 Ready Queue로 돌아간다.
* process는 Terminated 될 떄까지 위의 과정을 반복한다.

## Schedulers

OS에서는 스케쥴링을 위해 어떤 방식으로 이루어진 몇몇 큐에 있는 프로세스를 선택해야 하는데 이 일을 수행하는 것은 Scheduler라고 한다.
배치 시스탬은 종종 process가 급작스럽게 많아지게 되면 disk에 process를 저장한다. long-term Scheduler(job Scheduler)는 저런 process들을 실행시키기 위해 memory로 불러오는 역활을 하며, short-term Scheduler(CPU Scheduler)는 실행이 준비가 된 process들 중 하나를 CPU에 할당한다. 두 scheduler의 가장 큰 차이점은 실행 빈도이다. 

short-term Scheduler는 CPU에 할당 시킬 process를 선택한다. 그래서 short-term Scheduler는 빠르게 작동해야한다. 

![long-term Scheduler](http://cfile7.uf.tistory.com/image/123A763350E18EBC2FCF47)
출처 : [빛나유님 블로그](http://operatingsystems.tistory.com/entry/OS-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC-scheduler)


반면에 long-term Scheduler는 disk에 있는 code를 memory로 이전시키는 역활을 하기 떄문에 short-term Scheduler와는 상대적으로 빈도수가 적게 일을 한다. ([참고자료](http://operatingsystems.tistory.com/entry/OS-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC-scheduler))


![short-term Scheduler](http://cfile9.uf.tistory.com/image/2552DD3650E18ECE0AABEC)
출처 : [빛나유님 블로그](http://operatingsystems.tistory.com/entry/OS-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC-scheduler)

대부분의 process들은 I/O bound 이냐 CPU bound 이냐로 나뉜다. I/O bound process의 경우는 처리되는 시간을 I/O처리에 두고, CPU bound process의 경우는 처리되는 시간을 CPU 연산에 둔다. long-term Scheduler는 이 두가지의 process들을 잘 결합해서 스케쥴링을 해야한다.

어떠한 시스탬은 long-term Scheduler를 빼거나 축소 시킨다. 시분할이 적용된 OS들(UNIX, WINDOWS 등)에서는 중간 단계의 스케줄링인 medium-term scheduler를 사용한다. medium-term scheduler의 핵심은 오랫동안 사용되지 않는 process를 메모리에서 뺴서 다른 저장공간(ex. disk, usb 등)에 두고 필요 할 떄 다시 메모리로 불러오는 방식이며 이 구동을 swapping이라고 한다.

![medium-term-scheduling](/images/2017-02-05-jump-to-OS/medium-term-scheduling.PNG)

## context switch

interrupt는 CPU의 처리를 기존 작업에서 kernel routine으로 바꾼다. interrupt가 일어나 기존 작업에 대한 정보(the current **context** of the process running on the CPU)를 저장한다. 그래야만 중단된 지점부터 다시 실행할 수 있기 때문이다. 

CPU가 다른 process로 전환시 현재 process의 상태 정보(PCB)을 저장하고 작업해야할 process의 상태 정보를 불러오는 과정을 **context switch**라고 한다. 

# Operations on Process

대부분의 시스템의 process들은 동시에 실행되며, 동적으로 실행되거나 죽는다.

## Process Creation

process는 다른 process에 의해 생성된다.(그리고 그 프로세스를 child process라고 한다.) 그런 행위들이 반복해서 일어나면 계층이 생기고 그 모양을 도식화 시키면 Tree가 된다.각각의 Process는 PID(프로세스 식별자)가 존재한다.

![tree-of-processes](/images/2017-02-05-jump-to-OS/tree-of-processes.PNG)

init process는 root 프로세스이며 모든 프로세스의 부모가 된다. init process을 통해 다른 프로세스를 만들어내며 사용자의 메인프로세스나 web server, print server, ssh로 접속한 사용자까지 생성해 낸다. linux에서 process 목록을 보고 싶다면 다음 명령어를 사용하면 된다.

    ps -el

보통 child process가 만들어 질 때, 일정한 리소스 (CPU time, memory, files, I/O devices)가 필요하다. 이 리소스는 OS가 주거나 부모 process의 subset 자원으로서 할당 되어(공유하며) 사용할 수도 있다. 새로운 process가 생성되면,

1. 부모와 자식 process가 동시에 실행된다.
2. 부모는 자식이 끝날 떄까지 기다린다.

또한 두가지의 주소 공간을 가질 수 있다.

1. 부모를 복사한다.
2. 새로운 프로그램으로 로드 된다.

이러한 차이를 알기 위해서는 UNIX OS을 조금 알아야한다. UNIX에서는 fork()라는 system call을 이용하여 새로운 process를 만든다. fork()를 이용하면 기존의 PID를 반납하는 부모 process와 PID = 0을 반환하는 자식 process를 생성하여 각자가 할 일을 하며 다음과 같이 사용하면 됩니다.

````
#include <stdio.h>

int main() {
	pid_t pid;    // 프로세스 번호 (Process ID; PID)가 저장될 변수 pid
	
	pid = fork(); // 자식 프로세스를 생성한다. 
  						  // 성공시 0, 실패시 -1, 부모 프로세스이면 양수 (프로세스 ID)를 반환한다.
	if (pid < 0) {
		// pid 가 음수이면 에러가 난 것이다.
		fprintf(stderr, "fork failed!");
		return -1;
	} else if (pid == 0) {
		// pid 가 0 이면 자식 프로세스이다.
		// 자식 프로세스가 해야 할 일
		printf("자식 프로세스 (#%i)", getpid());

	} else {
		// pid 가 양수이면 부모 프로세스이다.
		// 부모 프로세스가 해야 할 일
      	printf("부모 프로세스 (#%i)", getpid());
		wait(NULL);  // 자식 프로세스들이 모두 종료될 때 까지 기다린다.
	}
	return 0;
}
````

fork() 후에 보통은 두 process중 하나는 exec()라는 system call을 사용하여 새로운 프로그램을 해당 process에 로딩한다(exec()를 실행한 process의 메모리는 파괴된다.).([이렇게 생성하는 이유! : 뎃글에 shell 프로그램을 예시로 설명함.](https://kldp.org/node/141415))
exec() system call은 바이너리 파일을 메모리로 로딩하고 실행한다. 위의 방법을 사용하면 서로의 process는 통신이 가능하며 다른 일이 가능해진다. 부모 프로세스는 다른 자식 프로세스를 만들거나 wait() system을 이용하여 ready queue로 돌아간 후 자식 프로세스가 끝나기를 기다린다. 

![using-fork](/images/2017-02-05-jump-to-OS/using-fork.PNG)

## Process Termination

process가 종료되는 시점은 process의 마지막 명령을 실행했거나 exit() system call을 사용하는 경우 발생한다. process 가 종료되면 종료 상태 값(보통 int)을 반환하며 OS에서는 모든 리소스를 반환시킨다.

부모 process가 자식 process를 죽이는 경우가 발생하는데 다음과 같다.

* 자식이 허용치 이상의 리소스를 사용하는 경우(죽여야 하는 상황을 감지하기 위해, 부모 process에 자식 리소스를 감시하는 기능을 가져야 한다.)
* 자식 process가 더 이상 필요 없는경우
* 부모 process가 종료 되는 경우.(OS가 자동으로 종료 시킨다. 이런 현상을 cascading termination 이라고 한다.)

자식 process가 종료되면 커널에 리턴값을 넘기고 커널은 부모에게 그 값을 전달한다. 그러나 그 값을 넘기기 전에 부모 프로세스가 불의의 사고(다른 process가 죽임 등등)로 종료된다면 커널은 해당 자식 프로세스를 좀비 프로세스로 만든다.(wait()을 써야하는 이유, UNIX에서는 사실 좀비가 되면 부모가 없어지는게 아니고 init process가 임시로 부모 역활을 하게 된다.)

# interprocess Communication [[참고자료](http://talkingaboutme.tistory.com/551)]

process들은 독립적으로 혹은 서로 의존하며 동시에 실행되고 있다. **process는 독립적이다.** 
어떠한 process도 다른 process의 data를 공유할 수 없다. 만약 process가 서로간의 간섭이 가능하다면 process는 협동이 가능하다. 어떠한 다른 process와 data를 공유하는 process라면 이미 cooperating process 이다.
 프로세스 협력 할 수 있는 환경을 제공하기 위한 몇 가지 이유가 있다.

* Information sharing. 여러명의 사용자가 같은 곳의 정보를 사용하려 하는 경우, 동시에 접근이 가능하도록 해줘야 한다.
* Computation speedup. 어떠한 task를 빠르게 하기위해서는 task를 쪼개서 병렬로 처리하게 된다. 
* Modularity. 모듈러 유행을 따르고 싶어하는 경우이다. process나 threads로 나누어 처리하려한다.
* Convenience. 개인 유저일 경우라도 한번에 많은 task를 처리하고 싶어한다. 예를들면 워드를 작성하고 음악을 들으면서 컴파일하는 경우이다.

cooperating process는 data와 information을 교환을 허락하는 메카니즘인 interprocess communication(IPC)이 필요하다. IPC에는 2가지의 기본 모델이 있다.(shared memory, message passing).
 shared memory 모델에서는, cooperating process가 shared memory를 만든다. 그리고 공유되고 있는 메모리에서 data를 읽고 쓰며 정보를 교환한다.
 message passing 모델에서는 통신이 cooperating process들간의 메시지 교환을 통해 진행된다.

![sharedmemory-messagepassing](/images/2017-02-05-jump-to-OS/sharedmemory-messagepassing.PNG)

## Shared-Memory Ststems

일반적으로, Shared-Memory는 주소공간 안의 process가 생성해놓은 Shared-Memory 위치한다.

### producer-consumer problem

producer process는 정보를 생산하고 consumer process는 정보를 소비한다. 예를 들면, 컴파일러는 어셈블러에게 정보를 소비시켜 어셈블리코드를 생산한다. 그럼 어셈블러는 로더에게 어셈블리코드를 소비시켜 오브젝트 모듈을 만든다. 이 문제는 client-server 페러다임에 비유할 수 있다. 웹 서버가 html 파일을 만들어 client에게 전달하면 client는 브라우저를 통해 html을 소비하여 화면을 구성한다.

producer-consumer problem의 하나의 해결책은 shared-memory를 사용하는 것이다. producer와 consumer를 동시에 돌리기 위해서는 공용으로 사용하는 buffer가 필요하다.
 2가지 종류의 buffer를 사용한다. unbounded buffer로 크기제한이 없는 buffer 이다. consumer는 새로운 아이탬을 기다리겠지만 producer는 항상 새로운 아이탬을 만들어 낼 수 있다. bounded buffer는 크기의 제한을 두는 buffer이다. 이 경우에는 buffer가 비어있다면 consumer가 기다리게 되고, buffer가 가득차면 producer가 기다리게 된다. 

## Message-Passing Ststems

message-passing은 shared-memory없이도 process들의 동작을 동기화 시킬 수 있고, process간에 통신이 가능하도록 하는 메커니즘을 제공한다. 이 환경은 특히 네트워트 안에 다른 컴퓨터의 process와 통신하는 분산 환경에서 유용하다. 
message-passing 기능은 최소 2가지의 기능을 지원한다.

* send(message)
* receive(message)




참고자료 
* [tutorialspoint - OS](https://www.tutorialspoint.com/operating_system/)
* [빛나유님 블로그](http://operatingsystems.tistory.com/category/Operating%20Systems)
* [IPC 참고자료](http://talkingaboutme.tistory.com/551)

---------

대략적인 내용 정리 

* Boot loader 작동 프로세스 정리
* kernel - shell
* API in OS
* Job & task
  * Job = 사용자가 컴퓨터에게 일을 시키는 단위 = program group
  * Job Step = Job을 작게 나눈 단위 ==> 순차적으로 실행됨
  * Task = OS입장에서의 최소 단위 ==> Job Step을 나누어서 처리하기 위함.
  * Task를 보통 Process 혹은 Task라고 합니다.
* Interrupt
  * 실행 중인 프로그램을 중단하고 우선순위가 높은 다른 프로그램에게 CPU를 할당하여 실행하는 것.
  * 내부 인터럽트(소프트웨어 인터럽트), 외부 인터럽트(하드웨어 인터럽트)
    * 내부 인터럽트
      * 오버플로우 : 허가받은 영역이상의 메모리를 사용할 경우
      * 페이지 폴트 : 허가받지 않은 영역의 메모리를 참조하는 경우
      * 트레이스 : 디버그를 위해 프로그램을 한 명령씩 실행 하는 경우
      * 슈퍼파이져 콜 : 시스템 콜을 사용 한 경우
      * 명령 코드 이상 : 무효한 명령을 실행하는 경우
    * 외부 인터럽트
      * 기계 체크 인터럽트 : 하드웨어가 이상이 있을 경우
      * 타이머 인터럽트 : 일정시간 마다(주기적으로) 인터럽트를 강제로 발생시기는 경우
      * 입출력 인터럽트 : 입출력기기의 상태 변환시 발생
      * 콘솔 인터럽트 : 입출력기기의 조작시 발생
* Process
  * 사용자가 프로그램을 실행하면 OS는 그 내용을 메모리상으로 읽어드린다(로드). 로드된 프로그램을 프로세스라고 하며 하나의 프로그램은 한 개 이상의 프로세스를 만든다.
  * 멀티태스킹 : 여러 개의 task가 병행하여 작동하는 것.
  * TSS(Time Sharing System) : 여러 사용자에게 CPU 권한을 단시간동안 할당하는 시스템
  * Process Status
    * 대기 상태 : 입출력 동작을 기다리고 있는 상태
    * 실행 가능 상태 : CPU의 사용 권한 할당을 기다리고 있는 상태
    * 실행 상태 : 프로세스에 CPU의 사용 권한이 할당되어 실행되고 있는 상태
    * 대기 ==> 실행 가능 : 입출력 인터럽트
    * 실행 가능 ==> 실행 : 디스패치
    * 실행 ==> 실행 가능 : 프리엠션
    * ![asd](https://image.slidesharecdn.com/intermediateos-120421041906-phpapp01/95/intermediate-operating-systems-36-728.jpg?cb=1334982260)
  * 멀티태스킹 종류
    * 프리엠티브 : OS가 Task의 CPU의 사용권을 할당하고 강제적으로 태스크를 전환하는 방식.
    * 논프리엠티브 : Task가 CPU의 사용권을 정하고 할당 해제를 하는 방식
  * 프로세스 제어
    * PSW(Program Status Word) : 인터럽트로 인핸 중단된 프로그램의 상태나 연산의 종료 상태를 저장해 두는 레지스터
    * PCB(Process Control Block) : 각 프로세스의 CPU 상태(context)나 프로세스의 상태를 저장해두는 메모리 영역
    * 컨텍스트 스위치 : 인터럽트로 인한 Process 전환시 OS가 PCB를 저장하고 복원하는 것.
  * Scheduling(스케줄링)
    * OS가 여러 개의 프로세스를 처리할 떄 CPU를 할당할 순서를 정하는 것.
      * 스케줄러 방식
        * Round Robin : 프로세스가 기다리고 있는 순서대로 일정시간 처리 후 맨 뒤로 돌림.
        * 우선순위 방식 : 프로세스의 우선순위를 정해서 처리하는 방식
  * 프로세스 분기
    * fork()
      * 시스탬 콜을 이용하여 프로세스를 복사함.
      * 복사의 모체를 부모 프로세스, 복사 당한 객체를 자식 프로세스라 함.
      * 서로 다른 PCB를 사용하며 복사 당시 차이점은 자식 프로세스의 리턴 값(PID)는 0이다.
    * exec()
      * 복사된 자식 프로세스를 다른 프로그램에서 실행 하도록 지시하는 것.
    * wait()
      * 자식 프로세스를 종료시키는 시스탬 콜
      * 자식 프로세스가 끝나면 부모 프로세스가 진행됨.
  * 프로세스 동기(sync)
    * 배타 제어
      * 프로세스의 처리가 끝날 때까지 하나의 프로세스에게 자원을 독점시키는 것.
      * 여러 개의 프로세스가 파일이나 데이터베이스에 동시에 엑세스하면 데이터의 무결성(완벽하게 정확하다, 에러가 없다)이 손상 될 수 있다.
    * 세마포어 ([자료1](http://wonjayk.tistory.com/250), [자료2](https://webcache.googleusercontent.com/search?q=cache:HaPnCiqIUnQJ:https://www.joinc.co.kr/w/Site/system_programing/IPC/semaphores+&cd=7&hl=ko&ct=clnk&gl=kr), [자료3](http://croute.me/3))
      * 정해진 수 이상의 프로세스가 공유 자원에 동시에 엑세스 하지 않도록 카운터를 사용하여 제어하는 장치
      * 세마포어 작동 순서
        1. 세마포어는 운영체계 또는 커널의 한 지정된 저장장치 내 값이다.
        2. 값의 변경은 P와 V라는 명령에 의해서 이루어진다.
        3. 프로세스가 Critical section에 들어가면 P는 세마포의 값을 감소시킨다.
        4. 프로세스가 작업수행 후 Critical section에서 나오면 V가 세마포 값을 증가시킨다.
        5. 프로세스는 확인되는 값에 따라 자원을 활용, 또는 일정시간을 대기한다.
  * 데드락 (Deadlock)
    * 2개의 프로세스가 각자 사용하는 공유 자원을 잠근 체 서로의 공유 자원을 액세스 하려고 대기하는 상태. 
    * 이 경우 서로 무한하게 대기하게 된다.
    * 뮤텍스 : 카운터 값이 1인 세마포어와 같다.
  * 프로세스 간 통신
    * 프로세스는 각각의 독립된 메모리를 사용한다. 그래서 서로간의 데이터를 교환하지 못한다.
    * 프로세스끼리 통신을 할 떄는 OS를 거처서 통신한다.
    * 통신 종류
      * 메시지 큐 : OS의 메시지 큐를 사용하여 통신(1:1)
      * 파이프 : 여러 개의 프로세스 입출력을 연결하는 장치. 부모 자식 프로세스 간의 통신에 사용됨
      * 이름 붙은 파이프 : 위의 파이프와 같지만 부모 자식 프로세스 간 이외에도 사용이 가능하다.
  * 공유 메모리 : 여러 개의 프로세스에서 공통으로 사용할 수 있는 메모리 영역. 시스탬 콜을 사용하며 접속(attach), 연결해제(detach)를 이용한다.
  * 스레드
    * 프로세스 안에 프로그램 실행의 흐름
    * 분기가 가능해 여러 개의 스레드를 동시에 실행한다.( = 멀티스레드)
    * 멀티 프로세스와 멀티 스레드의 차이점은 멀티 프로세스는 각각의 독립된 메모리 공간을 사용하지만 멀티 스레드는 하나의 프로세스안에서 돌기 때문에 하나의 메모리를 사용한다.
