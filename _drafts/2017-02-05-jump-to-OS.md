---
layout: post
title: "Jump To OS?"
date: "2017-02-05"
---

# Intro

OS는 중요하고 프로그래머라면 누구든지 알고 있어야 하는 것이다. 라는 말을 프로그래밍하시는 분들이나 전산과 계열에서 대학을 졸업하신 분들이라면 한번쯤은 들어보셨겠죠? 그래서 저도 막상 대학에선 잘 이해 하지 못했던 운영체제에 대한 공부를 결심한 한지 약 2년째 되어가는 차에.. 회사 공부 발표를 운영체제로 정해버렸습니다.. ㅠㅠ 이걸 2주만에 공부할 수 있었던건 정말로 신입적응기간이기 때문인것 같은데... 이번에 정리를 잘 해놔서 가치 있는 글을 남겨보려 합니다.(뭐 또 끝내놓으면 사라질 글일 느낌이 없진 않습니다..)

참고자료 
* [tutorialspoint - OS](https://www.tutorialspoint.com/operating_system/)


# Process Concept

프로세스는 단순히 실행되고 있는 코드를 뜻하는 것이 아니다. 프로세스는 많은 것을 가지고 있는데 아래에 나열해본다.

![process-in-memory](/images/2017-02-05-jump-to-OS/process-in-memory.PNG)

* Program Counter : 명령어 주소 레지스터라고 불리우며 다음 번에 실행될 명령어의 주소를 가지고 있는 저장소.
* Stack : 임시적인 데이터(function parameters, return addresses, local variables)를 가지는 저장소이며 메모리 끝부터 0번지 방향으로 자료가 쌓인다.
* data section : global variables 저장소.
* heap : process가 실행되는 시간에 동적으로 할당되는 메모리 공간.

Program은 Process가 아니다. Program은 디스크에 저장된 실행코드의 리스트(실행파일)들 같은 **passive entity**이다. 반면 Process는 다음실행해야할 실행코드와 그 실행코드가 엮인 리소스와 같은 **active entity**이다. Program이 process가 되기 위해선 실행파일이 메모리로 불러와져야 한다. 같은 프로그램을 여러 사용자가 동시에 사용하거나 한 사용자가 같은 프로그램을 여러개 실행하여 사용하여도 동일한 process를 사용하는 것이 아닌 각각의 실행된 프로그램의 process를 사용하게 되는 것이다. process는 자신이 아닌 다른 process를 실행할 수 있다.

## Process State

![process-in-memory](/images/2017-02-05-jump-to-OS/diagram-of-process-state.PNG)

* New : Process가 만들어 진다.
* Running : 명령어가 실행되어지고 있다.
* Waiting : 어떠한 이벤트(I/O interrupt 등)로 인해서 기다리게 됨.
* Ready : 프로세서에 할당되길 기다린다.
* Terminated : 프로세스가 종료 되었다.


## PCB (Process Control Block)

OS안에서 각각의 process는 Process Contral Block(PCB)로 표현된다.

![PCB](/images/2017-02-05-jump-to-OS/PCB.PNG)

* Process state : 현재 프로세스의 상태이다( ready, waiting, running 등등)
* Program counter : 이 프로세스가 다음에 실행시켜야 할 명령어의 주소값.
* CPU registers : 프로세스의 다양한 상태값(stack pointer, condition code, index register)이나 interrupt로 인한 waiting 상황 발생시 process의 모든 값을 저장하는 장소.

![CPU-switch](/images/2017-02-05-jump-to-OS/CPU-switch.PNG)

* CPU-Scheduling infomation : cpu가 처리하는 스케쥴링 큐의 포인터나 스케쥴링의 기준이 되는 값을 저장.
* Memory-management information : OS가 관리하는 Memory ststem의 page table이나 segment table, base register, limit register 값이 들어있다.

![base-linit-register](/image/2017-02-05-jump-to-OS/base-limit-register.PNG)

* Accounting infomation : (process가) 사용중인 CPU, 실 사용시간, time limits, account numbers, job or process numbers 등의 정보가 들어있다.
* I/O status infomation : process에 할당된 I/O devices 리스트, 열고 있는 files 등의 정보가 들어있다.

# Process Scheduling

멀티프로그래밍의 목적 중 하나는 CPU가 노는 시간을 줄이는 것이다. 시분할의 목적은 process를 cpu에 자주 할당시켜 각각의 프로그램이 도는동안 상호 호환시키기 위해서다. 이 목적들을 위해 **process Scheduler**는 사용가능한 process를 선택하여 CPU에 실행시킨다.

## Scheduling Queues

![Job-Queue](/image/2017-02-05-jump-to-OS/Job-Queue.PNG)

process가 시스탬에 속하면 process는 **Job Queue**에 올라간다. process가 memory에 로딩이 되는 순간부터 ready나 Waiting상태일 경우 **Ready Queue**에 올라간다. **Ready Queue**는 보통 linked list로 저장이 되며 첫부분과 끝부분의 포인터를 가지는 구조이고, 각각의 PCB블럭은 각자 자신의 다음 실행해야할 PCB를 가리킨다.

**Job Queue**에는 다른 queue들이 존재한다. process가 CPU에 할당이 될 떄, process가 실행 중 갑작스럽게 종료 되거나, interrupt 당하거나, I/O Event를 기다리기 되기도 한다.


---------

대략적인 내용 정리 

* Boot loader 작동 프로세스 정리
* kernel - shell
* API in OS
* Job & task
  * Job = 사용자가 컴퓨터에게 일을 시키는 단위 = program group
  * Job Step = Job을 작게 나눈 단위 ==> 순차적으로 실행됨
  * Task = OS입장에서의 최소 단위 ==> Job Step을 나누어서 처리하기 위함.
  * Task를 보통 Process 혹은 Task라고 합니다.
* Interrupt
  * 실행 중인 프로그램을 중단하고 우선순위가 높은 다른 프로그램에게 CUP를 할당하여 실행하는 것.
  * 내부 인터럽트(소프트웨어 인터럽트), 외부 인터럽트(하드웨어 인터럽트)
    * 내부 인터럽트
      * 오버플로우 : 허가받은 영역이상의 메모리를 사용할 경우
      * 페이지 폴트 : 허가받지 않은 영역의 메모리를 참조하는 경우
      * 트레이스 : 디버그를 위해 프로그램을 한 명령씩 실행 하는 경우
      * 슈퍼파이져 콜 : 시스템 콜을 사용 한 경우
      * 명령 코드 이상 : 무효한 명령을 실행하는 경우
    * 외부 인터럽트
      * 기계 체크 인터럽트 : 하드웨어가 이상이 있을 경우
      * 타이머 인터럽트 : 일정시간 마다(주기적으로) 인터럽트를 강제로 발생시기는 경우
      * 입출력 인터럽트 : 입출력기기의 상태 변환시 발생
      * 콘솔 인터럽트 : 입출력기기의 조작시 발생
* Process
  * 사용자가 프로그램을 실행하면 OS는 그 내용을 메모리상으로 읽어드린다(로드). 로드된 프로그램을 프로세스라고 하며 하나의 프로그램은 한 개 이상의 프로세스를 만든다.
  * 멀티태스킹 : 여러 개의 task가 병행하여 작동하는 것.
  * TSS(Time Sharing System) : 여러 사용자에게 CPU 권한을 단시간동안 할당하는 시스템
  * Process Status
    * 대기 상태 : 입출력 동작을 기다리고 있는 상태
    * 실행 가능 상태 : CPU의 사용 권한 할당을 기다리고 있는 상태
    * 실행 상태 : 프로세스에 CPU의 사용 권한이 할당되어 실행되고 있는 상태
    * 대기 ==> 실행 가능 : 입출력 인터럽트
    * 실행 가능 ==> 실행 : 디스패치
    * 실행 ==> 실행 가능 : 프리엠션
    * ![asd](https://image.slidesharecdn.com/intermediateos-120421041906-phpapp01/95/intermediate-operating-systems-36-728.jpg?cb=1334982260)
  * 멀티태스킹 종류
    * 프리엠티브 : OS가 Task의 CPU의 사용권을 할당하고 강제적으로 태스크를 전환하는 방식.
    * 논프리엠티브 : Task가 CPU의 사용권을 정하고 할당 해제를 하는 방식
  * 프로세스 제어
    * PSW(Program Status Word) : 인터럽트로 인핸 중단된 프로그램의 상태나 연산의 종료 상태를 저장해 두는 레지스터
    * PCB(Process Control Block) : 각 프로세스의 CPU 상태(context)나 프로세스의 상태를 저장해두는 메모리 영역
    * 컨텍스트 스위치 : 인터럽트로 인한 Process 전환시 OS가 PCB를 저장하고 복원하는 것.
  * Scheduling(스케줄링)
    * OS가 여러 개의 프로세스를 처리할 떄 CPU를 할당할 순서를 정하는 것.
      * 스케줄러 방식
        * Round Robin : 프로세스가 기다리고 있는 순서대로 일정시간 처리 후 맨 뒤로 돌림.
        * 우선순위 방식 : 프로세스의 우선순위를 정해서 처리하는 방식
  * 프로세스 분기
    * fork()
      * 시스탬 콜을 이용하여 프로세스를 복사함.
      * 복사의 모체를 부모 프로세스, 복사 당한 객체를 자식 프로세스라 함.
      * 서로 다른 PCB를 사용하며 복사 당시 차이점은 자식 프로세스의 리턴 값(PID)는 0이다.
    * exec()
      * 복사된 자식 프로세스를 다른 프로그램에서 실행 하도록 지시하는 것.
    * wait()
      * 자식 프로세스를 종료시키는 시스탬 콜
      * 자식 프로세스가 끝나면 부모 프로세스가 진행됨.
  * 프로세스 동기(sync)
    * 배타 제어
      * 프로세스의 처리가 끝날 때까지 하나의 프로세스에게 자원을 독점시키는 것.
      * 여러 개의 프로세스가 파일이나 데이터베이스에 동시에 엑세스하면 데이터의 무결성(완벽하게 정확하다, 에러가 없다)이 손상 될 수 있다.
    * 세마포어 ([자료1](http://wonjayk.tistory.com/250), [자료2](https://webcache.googleusercontent.com/search?q=cache:HaPnCiqIUnQJ:https://www.joinc.co.kr/w/Site/system_programing/IPC/semaphores+&cd=7&hl=ko&ct=clnk&gl=kr), [자료3](http://croute.me/3))
      * 정해진 수 이상의 프로세스가 공유 자원에 동시에 엑세스 하지 않도록 카운터를 사용하여 제어하는 장치
      * 세마포어 작동 순서
        1. 세마포어는 운영체계 또는 커널의 한 지정된 저장장치 내 값이다.
        2. 값의 변경은 P와 V라는 명령에 의해서 이루어진다.
        3. 프로세스가 Critical section에 들어가면 P는 세마포의 값을 감소시킨다.
        4. 프로세스가 작업수행 후 Critical section에서 나오면 V가 세마포 값을 증가시킨다.
        5. 프로세스는 확인되는 값에 따라 자원을 활용, 또는 일정시간을 대기한다.
  * 데드락 (Deadlock)
    * 2개의 프로세스가 각자 사용하는 공유 자원을 잠근 체 서로의 공유 자원을 액세스 하려고 대기하는 상태. 
    * 이 경우 서로 무한하게 대기하게 된다.
    * 뮤텍스 : 카운터 값이 1인 세마포어와 같다.
  * 프로세스 간 통신
    * 프로세스는 각각의 독립된 메모리를 사용한다. 그래서 서로간의 데이터를 교환하지 못한다.
    * 프로세스끼리 통신을 할 떄는 OS를 거처서 통신한다.
    * 통신 종류
      * 메시지 큐 : OS의 메시지 큐를 사용하여 통신(1:1)
      * 파이프 : 여러 개의 프로세스 입출력을 연결하는 장치. 부모 자식 프로세스 간의 통신에 사용됨
      * 이름 붙은 파이프 : 위의 파이프와 같지만 부모 자식 프로세스 간 이외에도 사용이 가능하다.
  * 공유 메모리 : 여러 개의 프로세스에서 공통으로 사용할 수 있는 메모리 영역. 시스탬 콜을 사용하며 접속(attach), 연결해제(detach)를 이용한다.
  * 스레드
    * 프로세스 안에 프로그램 실행의 흐름
    * 분기가 가능해 여러 개의 스레드를 동시에 실행한다.( = 멀티스레드)
    * 멀티 프로세스와 멀티 스레드의 차이점은 멀티 프로세스는 각각의 독립된 메모리 공간을 사용하지만 멀티 스레드는 하나의 프로세스안에서 돌기 때문에 하나의 메모리를 사용한다.
